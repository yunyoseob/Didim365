# ✨ SpringBoot 파헤치기

🏫 강의 소개

```
스프링 부트의 핵심 기능을 코드로 직접 구현하면서 스프링 부트의 동작 원리와 스프링 부트에 적용된 스프링 프레임워크의 활용법을 익히게 되는 강의
```

📁 목차

```
4.  자동 구성 기반 애플리케이션
    - 4-1. 메타 어노테이션
    - 4-2. 자동 구성 정보 파일 분리 및 
            어노테이션 적용
    - 4.3. @Configuration과 
            proxyBeanMethods
         
5.  조건부 자동 구성
    - 5-1. @Conditional과 Condition
    - 5-2. 자동 구성 정보 대체하기

6. 외부 설정을 이용한 자동구성
    - 6-1. 자동 구성에 Environment  
            property 적용
    - 6-2. @Value와 PropertySourcesPlaceholderCOnfigurer

7. 스프링부트 자동 구성 살펴보기
    - 7-1. 자동 구성 분석 방법
    - 7-2. 자동 구성 조건 결과 확인
    - 7-3. Core 자동 구성 살펴보기
    - 7-4. Web 자동 구성 살펴보기
    - 7-5. Jdbc 자동 구성 살펴보기
```


# 4. 자동 구성 기반 애플리케이션

Spring Boot의 어노테이션 활용에 앞서서 스프링의 기본적인 어노테이션은 아래와 같다.

![image](https://user-images.githubusercontent.com/81727895/236685165-31855dec-c59b-4731-8193-90f4ea32c61a.png)


## **4-1. 메타 어노테이션**

어노테이션에 적용한 어노테이션을 메타 어노테이션이라고 한다.

### **4-1-1. 메타 어노테이션 살펴보기**

>  **SimpleHelloService.java**

```java
@Service
public class SimpleHelloService implements HelloService{
   ...
}
```

**✔️ @Service 어노테이션 구성 보기**

```java
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component
public @interface Service {
    @AliasFor(
        annotation = Component.class
    )
    String value() default "";
}
```

여기서, @Services는 @Component 어노테이션의 메타 어노테이션임을 알 수 있다.


>  **HelloController.java**

```java
@RestController
public class HelloController {
    ...
}
```

**✔️ @RestController 구성 보기**

```java
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Controller
@ResponseBody
public @interface RestController {
    @AliasFor(
        annotation = Controller.class
    )
    String value() default "";
}
```

HelloController 클래스 위에 있는 @RestController는 @Controller와 @ResponseBody의 메타 어노테이션이다.


**✔️ @Controller 구성 보기**

```java
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component
public @interface Controller {
    @AliasFor(
        annotation = Component.class
    )
    String value() default "";
}
```

RestController @interface위의 Controller는 @Component의 메타 어노테이션이다.

이를 그림으로 표현하면 아래와 같다.

![image](https://user-images.githubusercontent.com/81727895/236685498-04595be5-6c5b-488d-a4d2-9e84191fe1e6.png)

**✔️ Composed annotation(합성 애노테이션)**

이렇게 메타 애노테이션을 하나 이상 적용해서 만든 애노테이션을 합성 애노테이션이라고 한다.

클래스나 메서드에 부여하는 어노테이션이 가지고 있는 모든 메타 어노테이션이 적용되어 있는 것과 같다.


**🤔 기존에 있는 어노테이션만 사용해도 될 것 같은데, 굳이 메타 어노테이션을 사용하는 이유는?**

```
1.  개발자가 코드를 읽을 때, 해당 클래스가 스프링 빈으로 등록되는 지 파악함과 동시에 어노테이션의 기능과 역할에 대한 추가적인 정보를 얻을 수 있다

2. 어노테이션에 있어서 다른 부가적인 기능 및 효과를 기대할 수 있다.
```


### **4-1-2. 메타 어노테이션 활용 예제(@UnitTest)**

- HelloServiceTest.java

```java
package tobyspring.helloboot;

import org.junit.jupiter.api.Test;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

import static org.assertj.core.api.Assertions.assertThat;

public class HelloServiceTest {
    @Test
    void simpleHelloService(){
        System.out.println("==== simpleHelloService ====");
        SimpleHelloService helloService = new SimpleHelloService();

        String ret = helloService.sayHello("Test");
        assertThat(ret).isEqualTo("Simple HelloTest");
    }

    @Test
    void complexHelloService(){
        System.out.println("==== complexHelloService ====");
        ComplexHelloService helloService = new ComplexHelloService();

        String ret = helloService.sayHello("Test");
        assertThat(ret).isEqualTo("Complex HelloTest");
    }
}
```

- 출력 결과(테스트 이상 없음)

```
==== simpleHelloService ====
==== complexHelloService ====
```

Test 어노테이션을 붙여줌으로써 Test 기능임을 파악할 수 있으나, 어떤 테스트인지 알기 어렵다.

이를 UnitTest라는 메타 어노테이션을 만들어서 실행한다면 다음과 같이 수정할 수 있다.

```java
// @Retention과 @Target은 반드시 붙여줘야 하는 필수 옵션이다.
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@interface UnitTest{}

public class HelloServiceTest {
    @UnitTest
    void simpleHelloService(){
        ...
    }

    @Test
    void complexHelloService(){
        ...
    }
}
```

- 출력 결과

```
==== complexHelloService ====
```

어노테이션을 바꾸고 나니, complexHelloService() 메서드는 테스트가 실행 되었으나, simpleHelloService() 메서드는 실행되지 않은 것을 확인 할 수 있다.

- @Test 어노테이션이 없기 때문에, @UnitTest가 @Test의 메타 어노테이션인지 알 수 없기 때문이다.


```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@Test
@interface UnitTest{}
```

따라서, @Test 어노테이션을 추가로 메타어노테이션에 넣어주고, 테스트를 실행하면 정상적으로 두 메서드 다 테스트에 활용된 것을 알 수 있다.

### **4-1-3. 메타 어노테이션 활용 예제(@FastUnitTest)**

여기서, @UnitTest라는 메타 어노테이션에 더 빠른 단위 테스트라는 어노테이션을 만들 고 싶어서 FastUnitTest라는 어노테이션을 만들어본다고 하자.

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@UnitTest
@interface FastUnitTest{

}
```

![image](https://user-images.githubusercontent.com/81727895/236687284-c1448c7e-58ea-40a6-9f8c-d93ef8f1e455.png)

- @UnitTest를 어노테이션 타입에 적용할 수 없다고 표시된다.

```java
@Target(ElementType.METHOD)

@Target({ElementType.ANNOTATION_TYPE, ElementType.METHOD})
```

그 이유는 생성한 UnitTest 어노테이션의 Target의 범위가 METHOD에만 국한되어 있기 때문인데, 

이를 확장하여 ANNOTATION_TYPE도 추가해주면 @UnitTest 어노테이션도 메타 어노테이션에 활용될 수 있다.

## **4-2. 자동 구성 정보 파일 분리 및 어노테이션 적용**

앞서, 테스트 로직을 통해 메타 어노테이션을 활용하는 예시를 작성했다면, 이번에는 메타 애노테이션을 통해 자동 구성 정보를 분리해보도록 한다.

### **4-2-1. 메타 애노테이션 생성, Config 클래스 생성하기**

- RwkSpringBootAnnotation 애노테이션 생성하기

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Configuration
@ComponentScan
public @interface RwkSpringBootAnnotation {
}
```

@Configuration 어노테이션과 @ComponentScan 어노테이션의 메타 어노테이션을 생성하였다.

@Configuration 어노테이션의 경우 @Bean 어노테이션이 필수인데, 이를 Config 클래스에 분리시키도록 한다.

- Config.java

```java
...
public class Config {
    @Bean
    public ServletWebServerFactory servletWebServerFactory(){
        System.out.println("======== ServletWebServerFactory register =========");
        return new TomcatServletWebServerFactory();
    }

    @Bean
    public DispatcherServlet dispatcherServlet(){
        System.out.println("======== DispatcherServlet register =========");
        return new DispatcherServlet();
    }
}
```

- HelloBootApplication.java

```java
@RwkSpringBootAnnotation
public class HelloBootApplication {
    public static void main(String[] args){
        SpringApplication.run(HelloBootApplication.class, args);
    }
}
```

스프링 부트를 다시 실행 시켜보면 Config 클래스에 있는 Bean을 스캔하는 것을 알 수 있다.

- 출력 결과

```
...
======== ServletWebServerFactory register =========
...
======== DispatcherServlet register =========
...
```

### **4-2-2. 빈 오브젝트와 역할과 구분**

![image](https://user-images.githubusercontent.com/81727895/236689845-03b514ed-51ba-4367-9134-690f761227a1.png)


스프링 컨테이너가 생성하고 관리하는 빈은 크게 애플리케이션 로직 빈, 애플리케이션 인프라스트럭처 빈, 컨테이너 인프라스트럭처 빈으로 나눌 수 있다.

**1. 애플리케이션 로직 빈**

애플리케이션의 기능(비즈니스 로직, 도메인 로직)을 담고 있는 빈

**2. 애플리케이션 인프라스트럭처 빈**

기술과 관련된 것으로 직접 작성하지 않고, 사용하겠다고 작성한 빈 구성정보

**3. 컨테이너 인프라스트럭처 빈**

스프링 컨테이너 자신 혹은 기능을 확장하면서 추가해온 것들을 빈으로 등록시켜서 사용


![image](https://user-images.githubusercontent.com/81727895/236690191-c6b9a131-9179-4cb9-9267-44e395b669b2.png)


**스프링은 사용자 구성정보와 자동 구성정보를 통해 필요한 구성정보를 읽어온다.** 

### **4-2-3. @Import로 컴포넌트를 구성정보에 추가하기**

```
java
    ㄴ config
        ㄴ Config.java
    ㄴ tobyspring
        ㄴ helloboot
            ㄴ HelloBootApplication
            ㄴ @RwkSpringBootAnnotation
...
```

구성과 관련된 Config.java와 같은 클래스들을 config라는 패키지에 따로 분리한 뒤, 실행시키면 다음과 같은 에러가 난다.

```
***************************
APPLICATION FAILED TO START
***************************
```

이유는 HelloBootApplication에 있는 @RwkSpringBootApplication의 @ComponentScan 범위를 벗어낫기 때문이다.


이럴 경우, @Import 어노테이션을 통해 구성정보에 필요한 Class를 불러올 수 있다.


```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Configuration
@ComponentScan
@Import(Config.class)
public @interface RwkSpringBootAnnotation {
}
```
- 단, Import에 들어갈 class는 @Component 어노테이션이 있는 class거나, @Component의 메타 어노테이션이 있는 class여야 한다.

- 출력 결과

```
...
======== ServletWebServerFactory register =========
...
======== DispatcherServlet register =========
...
```

@Import 어노테이션으로 구성정보를 import 한 뒤, 다시 정상적으로 실행되는 것을 확인 할 수 있다.

**🤔 Import해야할 클래스들의 종류가 많아질 경우, 하나하나 @Import 안에 추가하기 불편해질텐데 이럴 경우에는 어떻게 해야 하나요?**

```java
public interface ImportSelector {
    String[] selectImports(AnnotationMetadata importingClassMetadata);

    @Nullable
    default Predicate<String> getExclusionFilter() {
        return null;
    }
}
```

스프링에 있는 ImportSelector 인터페이스를 활용하여 여러 개를 import 할 수 있다.


```java
public interface DeferredImportSelector extends ImportSelector
```


### **4-2-4. DeferredImportSelector를 구현하여 selectImports 메서드 작성하기**

**1. tobyspring.config.RwkAutoConfiguration.java**

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Configuration
public @interface RwkAutoConfiguration {
}
```


**2. resources/META-INF/spring/tobyspinrg.config.RwkAutoConfiguration.imports**

```
tobyspring.config.autoconfig.DispatcherServletConfig
tobyspring.config.autoconfig.TomcatWebServerConfig
```

- import 할 파일을 imports 파일에 작성한다.

**3. package tobyspring.config.AutoConfigImportSelector.java**

```java
public class AutoConfigImportSelector implements DeferredImportSelector{

    private final ClassLoader classLoader;

    public AutoConfigImportSelector(ClassLoader classLoader){
        this.classLoader=classLoader;
    }

    @Override
    public String[] selectImports(AnnotationMetadata importingClassMetadata) {
        // ImportCandidates::load -> imports 파일에 있는 클래스들을 클래스 로더로 읽어서 Iterable에 저장
        Iterable<String> candidates =ImportCandidates.load(RwkAutoConfiguration.class, classLoader);
        // new 키워드로 인스턴스 
        return StreamSupport.stream(candidates.spliterator(), false).toArray(String[]::new);
    }
}
```

**4. tobyspring.helloboot.RwkSpringBootAnnotation.java**

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Configuration
@ComponentScan
@Import(AutoConfigImportSelector.class)
public @interface RwkSpringBootAnnotation {
}
```

- AutoConfigImportSelector 클래스를 import 해준다.

- 출력 결과

```
...
======== ServletWebServerFactory register =========
...
======== DispatcherServlet register =========
...
```

## **4.3. @Configuration과 proxyBeanMethods**

> 🤔 RwkAutoConfiguration 어노테이션의 @Configuration 어노테이션에 proxyBeanMethods = false 속성을 추가한다면 어떻게 될까?


























