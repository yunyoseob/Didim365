# ✨ SpringBoot 파헤치기

🏫 강의 소개

```
스프링 부트의 핵심 기능을 코드로 직접 구현하면서 스프링 부트의 동작 원리와 스프링 부트에 적용된 스프링 프레임워크의 활용법을 익히게 되는 강의
```

📁 목차

```
4.  자동 구성 기반 애플리케이션 및 조건부 자동 구성
    - 4-1. 메타 어노테이션
    - 4-2. 자동 구성 정보 파일 분리 및 
            어노테이션 적용
    - 4.3. @Configuration과 
            proxyBeanMethods
    - 4-4. @Conditional과 Condition

5. 외부 설정을 이용한 자동구성
    - 6-1. 자동 구성에 Environment  
            property 적용
    - 6-2. @Value와 PropertySourcesPlaceholderConfigurer

6. 스프링부트 자동 구성 살펴보기
    - 7-1. 자동 구성 분석 방법
    - 7-2. Web 자동 구성 살펴보기
```


# 4. 자동 구성 기반 애플리케이션

Spring Boot의 어노테이션 활용에 앞서서 스프링의 기본적인 어노테이션은 아래와 같다.

![image](https://user-images.githubusercontent.com/81727895/236685165-31855dec-c59b-4731-8193-90f4ea32c61a.png)


## **4-1. 메타 어노테이션**

어노테이션에 적용한 어노테이션을 메타 어노테이션이라고 한다.

### **4-1-1. 메타 어노테이션 살펴보기**

>  **SimpleHelloService.java**

```java
@Service
public class SimpleHelloService implements HelloService{
   ...
}
```

**✔️ @Service 어노테이션 구성 보기**

```java
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component
public @interface Service {
    @AliasFor(
        annotation = Component.class
    )
    String value() default "";
}
```

여기서, @Services는 @Component 어노테이션의 메타 어노테이션임을 알 수 있다.


>  **HelloController.java**

```java
@RestController
public class HelloController {
    ...
}
```

**✔️ @RestController 구성 보기**

```java
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Controller
@ResponseBody
public @interface RestController {
    @AliasFor(
        annotation = Controller.class
    )
    String value() default "";
}
```

HelloController 클래스 위에 있는 @RestController는 @Controller와 @ResponseBody의 메타 어노테이션이다.


**✔️ @Controller 구성 보기**

```java
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component
public @interface Controller {
    @AliasFor(
        annotation = Component.class
    )
    String value() default "";
}
```

RestController @interface위의 Controller는 @Component의 메타 어노테이션이다.

이를 그림으로 표현하면 아래와 같다.

![image](https://user-images.githubusercontent.com/81727895/236685498-04595be5-6c5b-488d-a4d2-9e84191fe1e6.png)

**✔️ Composed annotation(합성 애노테이션)**

이렇게 메타 애노테이션을 하나 이상 적용해서 만든 애노테이션을 합성 애노테이션이라고 한다.

클래스나 메서드에 부여하는 어노테이션이 가지고 있는 모든 메타 어노테이션이 적용되어 있는 것과 같다.


**🤔 기존에 있는 어노테이션만 사용해도 될 것 같은데, 굳이 메타 어노테이션을 사용하는 이유는?**

```
1.  개발자가 코드를 읽을 때, 해당 클래스가 스프링 빈으로 등록되는 지 파악함과 동시에 어노테이션의 기능과 역할에 대한 추가적인 정보를 얻을 수 있다

2. 어노테이션에 있어서 다른 부가적인 기능 및 효과를 기대할 수 있다.
```


### **4-1-2. 메타 어노테이션 활용 예제**

- HelloServiceTest.java

```java
package tobyspring.helloboot;

import org.junit.jupiter.api.Test;
...
import static org.assertj.core.api.Assertions.assertThat;

public class HelloServiceTest {
    @Test
    void simpleHelloService(){
        System.out.println("==== simpleHelloService ====");
        SimpleHelloService helloService = new SimpleHelloService();

        String ret = helloService.sayHello("Test");
        assertThat(ret).isEqualTo("Simple HelloTest");
    }

    @Test
    void complexHelloService(){
        System.out.println("==== complexHelloService ====");
        ComplexHelloService helloService = new ComplexHelloService();

        String ret = helloService.sayHello("Test");
        assertThat(ret).isEqualTo("Complex HelloTest");
    }
}
```

- 출력 결과(테스트 이상 없음)

```
==== simpleHelloService ====
==== complexHelloService ====
```

Test 어노테이션을 붙여줌으로써 Test 기능임을 파악할 수 있으나, 어떤 테스트인지 알기 위해, 메타 어노테이션을 만든다고 가정하자.

이 때, 임의로 UnitTest라는 메타 어노테이션을 만들어서 실행할 수 있다.

```java
// @Retention과 @Target은 반드시 붙여줘야 하는 필수 옵션이다.
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD) 
/* 
@Target({ElementType.ANNOTATION_TYPE, ElementType.METHOD})으로 작성할 경우, 다른 어노테이션이 @UnitTest 어노테이션을 활용할 수 있다. */
@Test 
/* @Test 어노테이션이 없으면, @UnitTest가 @Test의 메타 어노테이션인지 알 수 없으므로, 넣어주어야 한다. */
@interface UnitTest{}

public class HelloServiceTest {
    @UnitTest
    void simpleHelloService(){
        ...
    }

    @Test
    void complexHelloService(){
        ...
    }
}
```

## **4-2. 자동 구성 정보 파일 분리 및 어노테이션 적용**

앞서, 테스트 로직을 통해 메타 어노테이션을 활용하는 예시를 작성했다면, 이번에는 메타 애노테이션을 통해 자동 구성 정보를 분리해보도록 한다.

### **4-2-1. 메타 애노테이션 생성, Config 클래스 생성하기**

- RwkSpringBootAnnotation 애노테이션 생성하기

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Configuration
@ComponentScan
public @interface RwkSpringBootAnnotation {
}
```

@Configuration 어노테이션과 @ComponentScan 어노테이션의 메타 어노테이션을 생성하였다.

@Configuration 어노테이션의 경우 @Bean 어노테이션이 필수인데, 이를 Config 클래스에 분리시키도록 한다.

- Config.java

```java
...
public class Config {
    @Bean
    public ServletWebServerFactory servletWebServerFactory(){
        System.out.println("======== ServletWebServerFactory register =========");
        return new TomcatServletWebServerFactory();
    }

    @Bean
    public DispatcherServlet dispatcherServlet(){
        System.out.println("======== DispatcherServlet register =========");
        return new DispatcherServlet();
    }
}
```

- HelloBootApplication.java

```java
@RwkSpringBootAnnotation
public class HelloBootApplication {
    public static void main(String[] args){
        SpringApplication.run(HelloBootApplication.class, args);
    }
}
```

스프링 부트를 다시 실행 시켜보면 Config 클래스에 있는 Bean을 스캔하는 것을 알 수 있다.

- 출력 결과

```
...
======== ServletWebServerFactory register =========
...
======== DispatcherServlet register =========
...
```

### **4-2-2. 빈 오브젝트와 역할과 구분**

![image](https://user-images.githubusercontent.com/81727895/236689845-03b514ed-51ba-4367-9134-690f761227a1.png)


스프링 컨테이너가 생성하고 관리하는 빈은 크게 애플리케이션 로직 빈, 애플리케이션 인프라스트럭처 빈, 컨테이너 인프라스트럭처 빈으로 나눌 수 있다.

**1. 애플리케이션 로직 빈**

애플리케이션의 기능(비즈니스 로직, 도메인 로직)을 담고 있는 빈

**2. 애플리케이션 인프라스트럭처 빈**

기술과 관련된 것으로 직접 작성하지 않고, 사용하겠다고 작성한 빈 구성정보

**3. 컨테이너 인프라스트럭처 빈**

스프링 컨테이너 자신 혹은 기능을 확장하면서 추가해온 것들을 빈으로 등록시켜서 사용


![image](https://user-images.githubusercontent.com/81727895/236690191-c6b9a131-9179-4cb9-9267-44e395b669b2.png)


**스프링은 사용자 구성정보와 자동 구성정보를 통해 필요한 구성정보를 읽어온다.** 

### **4-2-3. @Import로 컴포넌트를 구성정보에 추가하기**

```
java
    ㄴ config
        ㄴ Config.java
    ㄴ tobyspring
        ㄴ helloboot
            ㄴ HelloBootApplication
            ㄴ @RwkSpringBootAnnotation
...
```

구성과 관련된 Config.java와 같은 클래스들을 config라는 패키지에 따로 분리한 뒤, 실행시키면 다음과 같은 에러가 난다.

```
***************************
APPLICATION FAILED TO START
***************************
```

이유는 HelloBootApplication에 있는 @RwkSpringBootApplication의 @ComponentScan 범위를 벗어낫기 때문이다.


이럴 경우, @Import 어노테이션을 통해 구성정보에 필요한 Class를 불러올 수 있다.


```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Configuration
@ComponentScan
@Import(Config.class)
public @interface RwkSpringBootAnnotation {
}
```
- 단, Import에 들어갈 class는 @Component 어노테이션이 있는 class거나, @Component의 메타 어노테이션이 있는 class여야 한다.

- 출력 결과

```
...
======== ServletWebServerFactory register =========
...
======== DispatcherServlet register =========
...
```

@Import 어노테이션으로 구성정보를 import 한 뒤, 다시 정상적으로 실행되는 것을 확인 할 수 있다.

**🤔 Import해야할 클래스들의 종류가 많아질 경우, 하나하나 @Import 안에 추가하기 불편해질텐데 이럴 경우에는 어떻게 해야 하나요?**

```java
public interface ImportSelector {
    String[] selectImports(AnnotationMetadata importingClassMetadata);

    @Nullable
    default Predicate<String> getExclusionFilter() {
        return null;
    }
}
```

스프링에 있는 ImportSelector 인터페이스를 활용하여 여러 개를 import 할 수 있다.


```java
public interface DeferredImportSelector extends ImportSelector
```


### **4-2-4. DeferredImportSelector를 구현하여 selectImports 메서드 작성하기**

**1. tobyspring.config.RwkAutoConfiguration.java**

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Configuration
public @interface RwkAutoConfiguration {
}
```


**2. resources/META-INF/spring/tobyspinrg.config.RwkAutoConfiguration.imports**

```
tobyspring.config.autoconfig.DispatcherServletConfig
tobyspring.config.autoconfig.TomcatWebServerConfig
```

- import 할 파일을 imports 파일에 작성한다.

**3. package tobyspring.config.AutoConfigImportSelector.java**

```java
public class AutoConfigImportSelector implements DeferredImportSelector{

    private final ClassLoader classLoader;

    public AutoConfigImportSelector(ClassLoader classLoader){
        this.classLoader=classLoader;
    }

    @Override
    public String[] selectImports(AnnotationMetadata importingClassMetadata) {
        // ImportCandidates::load -> imports 파일에 있는 클래스들을 클래스 로더로 읽어서 Iterable에 저장
        Iterable<String> candidates =ImportCandidates.load(RwkAutoConfiguration.class, classLoader);
        // new 키워드로 인스턴스 
        return StreamSupport.stream(candidates.spliterator(), false).toArray(String[]::new);
    }
}
```

**4. tobyspring.helloboot.RwkSpringBootAnnotation.java**

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Configuration
@ComponentScan
@Import(AutoConfigImportSelector.class)
public @interface RwkSpringBootAnnotation {
}
```

- AutoConfigImportSelector 클래스를 import 해준다.

- 출력 결과

```
...
======== ServletWebServerFactory register =========
...
======== DispatcherServlet register =========
...
```

## **4.3. @Configuration과 proxyBeanMethods**

01.SpringBoot살펴보기 편에서 싱글톤 레지스트리 언급을 했었다.

```
스프링 애플리케이션에서는 싱글톤 패턴과 유사하게 애플리케이션이 동작하는 동안 딱 하나의 오브젝트만을 만들고 사용되게 만들어 준다. 이런 면에서 스프링 컨테이너는 싱글톤 레지스트리라고 한다.
```

@Configuration 어노테이션이 붙은 클래스의 각 @Bean을 항상 싱글톤으로 유지해주는지 테스트를 해보자.

### **4.3.1. @Configuration 싱글톤 테스트 예제**

- Common.java

```java
public class Common {
}
```


- ConfigurationTest.java 

```java
public class ConfigurationTest {
    @Configuration
    static class MyConfig {
        @Bean
        Common common() {
            return new Common();
        }

        @Bean
        Bean1 bean1() {
            return new Bean1(common());
        }

        @Bean
        Bean2 bean2() {
            return new Bean2(common());
        }
    }

    static class Bean1 {
        private final Common common;

        Bean1(Common common) {
            this.common = common;
        }
    }

    static class Bean2 {
        private final Common common;

        Bean2(Common common) {
            this.common = common;
        }
    }
}
```

다음과 같이 ConfigurationTest 클래스가 구성되어 있을 때, 각 싱글톤 레지스트리 테스트 결과는 아래와 같다.

**1. MyConfig.class를 ApplicationContext에 빈으로 등록 후, 테스트**

```java
@Test
void configuration() {
    AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext();
    ac.register(MyConfig.class);
    ac.refresh();

    Bean1 bean1 = ac.getBean(Bean1.class);
    Bean2 bean2 = ac.getBean(Bean2.class);

    // isSameAs : 같은 오브젝트인지 주소값까지 비교
    assertThat(bean1.common).isSameAs(bean2.common);
    // 테스트 통과
}
```

- 테스트 결과 : 성공(두 객체의 주소값이 같음)

**2. MyConfig.class를 인스턴스 한 뒤에, 각 함수로 부터 Bean1, Bean2 클래스 참조변수를 받아 온 뒤, 비교 테스트**

```java
@Test
void configuration() {
    MyConfig myConfig = new MyConfig();
    Bean1 bean1 = myConfig.bean1();
    Bean2 bean2 = myConfig.bean2();

    assertThat(bean1.common).isSameAs(bean2.common);
}
```
- 테스트 결과 : 실패(두 객체의 주소값이 다름)


**3. MyConfig 클래스를 상속한 MyConfigProxy 클래스를 생성한 뒤, 싱글톤으로 Common 클래스 변수 리턴했을 때, 비교 테스트**


```java
// 추가된 부분
static class MyConfigProxy extends MyConfig {
    private Common common;

    @Override
    Common common() {
        if (this.common == null) this.common = super.common();
             return this.common;
    }
}

@Test
void proxyCommonMethod() {
    MyConfigProxy myConfigProxy = new MyConfigProxy();
    Bean1 bean1 = myConfigProxy.bean1();
    Bean2 bean2 = myConfigProxy.bean2();
    assertThat(bean1.common).isSameAs(bean2.common);
    // 테스트 통과
}
```

- 테스트 결과 : 성공(두 객체의 주소값이 같음)


**✔️ 스프링은 한 개의 오브젝트만 사용하게 되는데, 만약 하나의 빈을 두 개 이상의 다른 빈에서 의존하고 있다면 FactoryMethod를 호출할 때마다, 새로운 빈이 만들어지는 문제가 생긴다.**

> **스프링은 이 문제를 해결하기 위해 @Configuration이 어노테이션이 붙은 클래스는 기본적으로 Proxy를 만들어서 이를 해결해준다.**

### **4.3.2. @Configuration(proxyBeanMethods = false)로 설정 후, 싱글톤 레지스트리 테스트**


이 때, @Configuration(proxyBeanMethods = false)로 설정했을 때, 테스트 결과는 아래와 같다.

```java
// 수정된 부분
@Configuration(proxyBeanMethods = false)
static class MyConfig {
    ...
}
```

```
**테스트 1 : 실패 (두 주소값이 다름)**

테스트 2 : 실패 (두 주소값이 다름)

테스트 3 : 성공 (두 주소값이 같음)
```

차이는 MyConfig.class를 ApplicationContext에 빈으로 등록 후, 테스트하였을 때, proxyBeanMethods = true 였을 시에는 성공이였는데, false로 바꾸자 실패하였다.

이유는 @Configuration이 붙은 클래스를 빈으로 등록 할 때, Proxy를 만들지 않고, 자바 코드 그대로 동작하게 만들었기 때문이다.

### **4.3.3. @Configuration(proxyBeanMethods = false)로 실제 활용 예시**

- @EnableScheduling

```java
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Import({SchedulingConfiguration.class})
@Documented
public @interface EnableScheduling {
}
```

- SchedulingConfiguration.class

```java
@Configuration(
    proxyBeanMethods = false
)
@Role(2)
public class SchedulingConfiguration {
    public SchedulingConfiguration() {
    }

    @Bean(
        name = {"org.springframework.context.annotation.internalScheduledAnnotationProcessor"}
    )
    @Role(2)
    public ScheduledAnnotationBeanPostProcessor scheduledAnnotationProcessor() {
        return new ScheduledAnnotationBeanPostProcessor();
    }
}
```

SchedulingConfiguration 소스 코드를 보면, Bean을 하나 생성하는 코드가 있는데, 

해당 Bean은 생성하는 동안에, 다른 오브젝트를 의존하고 있지 않다.

이런 경우, 매번 Proxy를 만들어서 적용할  필요가 없다고 판단하여 proxyBeanMethods를 false로 설정한 케이스이다.

## **4.4. @Conditional과 Condition**































